# 性能优化说明

本文档说明了在微信支付集成中实施的性能优化措施。

## 优化概述

根据需求 4.3、8.2 和 8.3，我们实施了以下性能优化：

1. **余额缓存（Vuex）** - 在 Vuex store 中缓存账户余额
2. **API 调用防抖** - 防止快速连续的 API 调用
3. **请求取消** - 取消过时的请求
4. **加载状态** - 防止重复提交

## 实现细节

### 1. 余额缓存（Requirement 4.3）

**位置：** `store/index.js`

**实现：**
```javascript
state: {
  accountBalance: 0  // 缓存的账户余额
},
mutations: {
  SET_ACCOUNT_BALANCE(state, val) {
    state.accountBalance = val
  }
},
actions: {
  updateAccountBalance({commit}, balance) {
    commit('SET_ACCOUNT_BALANCE', balance)
  }
}
```

**使用场景：**
- 每次成功获取余额后，更新 Vuex 缓存
- 当 API 调用失败时，返回缓存的余额并显示警告
- 页面刷新时优先显示缓存的余额

**优势：**
- 减少不必要的 API 调用
- 提供更快的用户体验
- 在网络错误时提供降级方案

### 2. API 调用防抖（Requirement 8.2）

**位置：** `common/js/performanceOptimizer.js`

**实现：**
```javascript
debounce(func, delay = 300, key = 'default') {
  return (...args) => {
    if (this.debouncedFunctions.has(key)) {
      clearTimeout(this.debouncedFunctions.get(key))
    }
    const timer = setTimeout(() => {
      func.apply(this, args)
      this.debouncedFunctions.delete(key)
    }, delay)
    this.debouncedFunctions.set(key, timer)
  }
}
```

**使用场景：**

#### My 页面余额刷新
```javascript
// 在 onLoad 中创建防抖版本
this.debouncedGetMoney = performanceOptimizer.debounce(
  this.getMyMoney.bind(this),
  500,
  'my_page_balance'
)

// 在 onShow 中使用防抖版本
onShow() {
  this.debouncedGetMoney()  // 防止快速切换页面时的重复调用
}
```

#### 充值记录列表
```javascript
// 创建防抖版本
this.debouncedGetList = performanceOptimizer.debounce(
  this.getList.bind(this),
  500,
  'recharge_record_list'
)
```

**优势：**
- 防止用户快速操作导致的重复 API 调用
- 减少服务器负载
- 提高应用响应性

### 3. 请求节流（Requirement 8.2）

**位置：** `common/js/performanceOptimizer.js`

**实现：**
```javascript
shouldThrottle(key, minInterval = 1000) {
  const now = Date.now()
  const lastCall = this.requestTimestamps.get(key)
  
  if (lastCall && (now - lastCall) < minInterval) {
    console.log(`[Performance] Throttled request: ${key}`)
    return true
  }
  
  this.requestTimestamps.set(key, now)
  return false
}
```

**使用场景：**

#### 余额查询节流
```javascript
// 在 paymentService.getBalance 中
if (performanceOptimizer.shouldThrottle(`balance_${userId}`, 1000)) {
  console.log('[Balance] Request throttled, returning cached balance')
  const cachedBalance = store.state.accountBalance
  if (cachedBalance !== undefined && cachedBalance !== null) {
    return cachedBalance
  }
}
```

#### 充值记录节流
```javascript
// 在 paymentService.getPaymentHistory 中
if (performanceOptimizer.shouldThrottle(`history_${userId}`, 2000)) {
  console.log('[Payment History] Request throttled')
  throw new Error('请求过于频繁，请稍后再试')
}
```

**优势：**
- 确保最小请求间隔
- 防止恶意或意外的频繁请求
- 保护后端 API

### 4. 请求取消（Requirement 8.3）

**位置：** `common/js/performanceOptimizer.js`

**实现：**
```javascript
async wrapApiCall(requestKey, apiCall) {
  // 检查是否有相同的待处理请求
  if (this.isRequestPending(requestKey)) {
    console.log(`[Performance] Duplicate request detected, cancelling previous: ${requestKey}`)
    this.cancelRequest(requestKey)
  }
  
  try {
    const requestPromise = apiCall()
    this.registerRequest(requestKey, requestPromise)
    const result = await requestPromise
    this.unregisterRequest(requestKey)
    return result
  } catch (error) {
    this.unregisterRequest(requestKey)
    throw error
  }
}
```

**使用场景：**

#### 余额查询
```javascript
// 创建唯一请求键
const requestKey = performanceOptimizer.createRequestKey('/record/accountMoney', { userId })

// 包装 API 调用
const response = await performanceOptimizer.wrapApiCall(requestKey, () => {
  return uni.$u.api.GET(requestUrl, { userId: userId })
})
```

#### 充值记录查询
```javascript
const requestKey = performanceOptimizer.createRequestKey(url.topUpRecord, this.params)

performanceOptimizer.wrapApiCall(requestKey, () => {
  return this.$u.api.GET(url.topUpRecord, this.params)
})
```

**优势：**
- 自动取消过时的请求
- 防止竞态条件
- 确保只处理最新的请求结果

### 5. 加载状态（Requirement 8.3）

**实现：**

#### My 页面
```javascript
data() {
  return {
    isLoadingBalance: false
  }
},
methods: {
  async getMyMoney() {
    if (this.isLoadingBalance) {
      console.log('[Balance] Already loading, skipping duplicate request')
      return
    }
    
    this.isLoadingBalance = true
    try {
      // ... API 调用
    } finally {
      this.isLoadingBalance = false
    }
  }
}
```

#### 充值页面
```javascript
data() {
  return {
    isPaymentProcessing: false
  }
},
methods: {
  async confirmPay() {
    if (this.isPaymentProcessing) {
      console.log('[Payment] Already processing, preventing duplicate submission')
      uni.showToast({
        title: '支付处理中，请稍候',
        icon: 'none'
      })
      return
    }
    
    this.isPaymentProcessing = true
    try {
      // ... 支付逻辑
    } finally {
      this.isPaymentProcessing = false
    }
  }
}
```

#### 充值记录页面
```javascript
data() {
  return {
    isLoadingList: false
  }
},
methods: {
  getList() {
    if (this.isLoadingList) {
      console.log('[Recharge Record] Already loading, skipping duplicate request')
      return
    }
    
    this.isLoadingList = true
    // ... API 调用
    .finally(() => {
      this.isLoadingList = false
    })
  }
}
```

**优势：**
- 防止用户重复点击导致的重复提交
- 提供清晰的加载反馈
- 避免并发请求冲突

## 性能指标

### 优化前
- 余额查询：每次页面显示都发起新请求
- 快速切换页面：可能产生多个并发请求
- 重复点击：可能触发多次支付请求
- 无请求管理：过时的请求仍会处理

### 优化后
- 余额查询：优先使用缓存，最小间隔 1 秒
- 页面切换：防抖延迟 500ms，减少不必要的请求
- 重复点击：加载状态阻止重复提交
- 请求管理：自动取消过时的请求

## 使用示例

### 在新组件中使用性能优化

```javascript
import performanceOptimizer from '@/common/js/performanceOptimizer.js'

export default {
  data() {
    return {
      isLoading: false
    }
  },
  
  onLoad() {
    // 创建防抖函数
    this.debouncedFetch = performanceOptimizer.debounce(
      this.fetchData.bind(this),
      500,
      'my_component_fetch'
    )
  },
  
  methods: {
    async fetchData() {
      // 检查加载状态
      if (this.isLoading) {
        return
      }
      
      // 检查节流
      if (performanceOptimizer.shouldThrottle('my_data', 1000)) {
        return
      }
      
      this.isLoading = true
      
      try {
        // 创建请求键
        const requestKey = performanceOptimizer.createRequestKey('/api/data', { id: 123 })
        
        // 包装 API 调用
        const response = await performanceOptimizer.wrapApiCall(requestKey, () => {
          return uni.$u.api.GET('/api/data', { id: 123 })
        })
        
        // 处理响应
        console.log(response)
      } finally {
        this.isLoading = false
      }
    }
  }
}
```

## 注意事项

1. **防抖延迟**：根据具体场景调整延迟时间（默认 300ms）
2. **节流间隔**：根据 API 特性设置合适的最小间隔
3. **请求键**：确保请求键的唯一性，包含 URL 和参数
4. **加载状态**：始终在 finally 块中重置加载状态
5. **缓存策略**：定期清理过期的缓存数据

## 相关文件

- `common/js/performanceOptimizer.js` - 性能优化工具类
- `common/js/paymentService.js` - 支付服务（使用优化）
- `package/chargingPile/my/my.vue` - 我的页面（使用优化）
- `package/chargingPile/preTopUp.vue` - 充值页面（使用优化）
- `package/chargingPile/recharge-record/recharge-record.vue` - 充值记录（使用优化）
- `store/index.js` - Vuex store（余额缓存）

## 测试建议

1. **防抖测试**：快速切换页面，验证只发起一次请求
2. **节流测试**：连续点击刷新，验证请求间隔限制
3. **取消测试**：快速发起多个请求，验证只处理最后一个
4. **加载状态测试**：支付过程中重复点击，验证阻止重复提交
5. **缓存测试**：断网情况下，验证显示缓存的余额

## 未来改进

1. **智能缓存**：根据数据更新频率动态调整缓存策略
2. **请求队列**：实现请求队列管理，优化并发控制
3. **离线支持**：增强离线场景下的用户体验
4. **性能监控**：添加性能指标收集和分析
5. **自适应优化**：根据网络状况自动调整优化策略
