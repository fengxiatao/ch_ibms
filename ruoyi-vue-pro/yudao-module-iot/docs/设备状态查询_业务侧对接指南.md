# 设备状态查询 - 业务侧对接指南

## 概述

网关侧已实现统一的设备状态查询架构，支持多种设备类型的在线状态判断：
- **ConnectionPresenceProvider**：基于TCP/MQTT连接在场（适用于所有通过网关连接的设备）
- **OnvifPresenceProvider**：基于ONVIF协议探测（适用于网络摄像头）
- 未来可扩展：HeartbeatProvider、VendorSdkProvider等

业务侧需要集成网关的状态查询服务，在设备列表、设备详情等页面展示实时在线状态。

---

## 架构说明

### 网关侧（yudao-module-iot-gateway）

```
DeviceStatusController (HTTP API)
    ↓
DeviceStatusService (Facade)
    ↓
DeviceStatusAggregator (聚合多个Provider)
    ↓
├── ConnectionPresenceProvider (优先级100，最高)
├── OnvifPresenceProvider (优先级400)
└── 其他Provider...
    ↓
PresenceStore (Caffeine缓存，TTL 3秒)
```

### 业务侧（yudao-module-iot-biz）

```
IotDeviceController (设备管理接口)
    ↓
IotDeviceService
    ↓
调用网关 DeviceStatusController
    ↓
返回设备状态给前端
```

---

## 对接步骤

### 1. 网关侧：注册摄像头设备信息到 OnvifPresenceProvider

当创建或更新摄像头设备时，需要将设备信息注册到 `OnvifPresenceProvider`。

#### 方式A：通过消息总线（推荐）

**网关侧监听设备创建/更新事件**：

```java
@Component
@Slf4j
public class CameraDeviceRegistrationConsumer implements IotMessageSubscriber<IotDeviceMessage> {
    
    @Resource
    private OnvifPresenceProvider onvifPresenceProvider;
    
    @Resource
    private IotMessageBus messageBus;
    
    @PostConstruct
    public void subscribe() {
        messageBus.register(this);
    }
    
    @Override
    public String getTopic() {
        return "iot.device.camera.registered"; // 自定义主题
    }
    
    @Override
    public String getGroup() {
        return "gateway-onvif-registration";
    }
    
    @Override
    public void onMessage(IotDeviceMessage message) {
        Long deviceId = message.getDeviceId();
        
        // 从消息中获取摄像头信息
        String ip = (String) message.getData().get("ip");
        Integer port = (Integer) message.getData().get("onvifPort");
        String username = (String) message.getData().get("username");
        String password = (String) message.getData().get("password");
        
        // 注册到 OnvifPresenceProvider
        onvifPresenceProvider.registerDevice(deviceId, ip, port, username, password);
        
        log.info("[CameraDeviceRegistration] 注册摄像头设备: deviceId={}, ip={}", deviceId, ip);
    }
}
```

**业务侧发布设备注册事件**：

```java
@Service
public class IotCameraServiceImpl implements IotCameraService {
    
    @Resource
    private IotMessageBus messageBus;
    
    @Override
    public Long createCamera(IotCameraSaveReqVO createReqVO) {
        // 1. 创建摄像头设备
        IotCameraDO camera = // ... 保存到数据库
        
        // 2. 发布设备注册事件到网关
        IotDeviceMessage message = new IotDeviceMessage();
        message.setTopic("iot.device.camera.registered");
        message.setDeviceId(camera.getId());
        message.setData(MapUtil.builder()
                .put("ip", camera.getIp())
                .put("onvifPort", camera.getOnvifPort())
                .put("username", camera.getUsername())
                .put("password", camera.getPassword())
                .build());
        
        messageBus.publish(message);
        
        return camera.getId();
    }
}
```

#### 方式B：通过HTTP接口（简单直接）

**网关侧提供注册接口**：

```java
@RestController
@RequestMapping("/gateway/device/status")
public class DeviceStatusController {
    
    @Resource
    private OnvifPresenceProvider onvifPresenceProvider;
    
    /**
     * 注册ONVIF设备信息
     */
    @PostMapping("/onvif/register")
    public CommonResult<Boolean> registerOnvifDevice(@RequestBody OnvifDeviceRegisterReqVO reqVO) {
        onvifPresenceProvider.registerDevice(
                reqVO.getDeviceId(),
                reqVO.getIp(),
                reqVO.getPort(),
                reqVO.getUsername(),
                reqVO.getPassword()
        );
        return success(true);
    }
    
    /**
     * 注销ONVIF设备信息
     */
    @DeleteMapping("/onvif/unregister")
    public CommonResult<Boolean> unregisterOnvifDevice(@RequestParam("deviceId") Long deviceId) {
        onvifPresenceProvider.unregisterDevice(deviceId);
        return success(true);
    }
}
```

**业务侧调用注册接口**：

```java
@Service
public class IotCameraServiceImpl implements IotCameraService {
    
    @Resource
    private RestTemplate restTemplate;
    
    private static final String GATEWAY_URL = "http://localhost:48082"; // 网关地址
    
    @Override
    public Long createCamera(IotCameraSaveReqVO createReqVO) {
        // 1. 创建摄像头设备
        IotCameraDO camera = // ... 保存到数据库
        
        // 2. 注册到网关 OnvifPresenceProvider
        String url = GATEWAY_URL + "/gateway/device/status/onvif/register";
        OnvifDeviceRegisterReqVO registerReqVO = new OnvifDeviceRegisterReqVO();
        registerReqVO.setDeviceId(camera.getId());
        registerReqVO.setIp(camera.getIp());
        registerReqVO.setPort(camera.getOnvifPort());
        registerReqVO.setUsername(camera.getUsername());
        registerReqVO.setPassword(camera.getPassword());
        
        restTemplate.postForObject(url, registerReqVO, CommonResult.class);
        
        return camera.getId();
    }
}
```

---

### 2. 业务侧：查询设备在线状态

#### 单个设备查询

```java
@Service
public class IotDeviceServiceImpl implements IotDeviceService {
    
    @Resource
    private RestTemplate restTemplate;
    
    private static final String GATEWAY_URL = "http://localhost:48082";
    
    @Override
    public IotDeviceRespVO getDevice(Long id) {
        // 1. 查询设备基本信息
        IotDeviceDO device = deviceMapper.selectById(id);
        
        // 2. 查询设备在线状态（调用网关）
        String url = GATEWAY_URL + "/gateway/device/status/get?deviceId=" + id;
        DeviceStatusVO status = restTemplate.getForObject(url, DeviceStatusVO.class);
        
        // 3. 组装返回VO
        IotDeviceRespVO respVO = new IotDeviceRespVO();
        respVO.setId(device.getId());
        respVO.setDeviceName(device.getDeviceName());
        respVO.setOnline(status.getOnline());
        respVO.setStatus(status.getStatus());
        respVO.setLastChangeTime(status.getLastChangeTime());
        
        return respVO;
    }
}
```

#### 批量查询（设备列表）

```java
@Service
public class IotDeviceServiceImpl implements IotDeviceService {
    
    @Override
    public PageResult<IotDeviceRespVO> getDevicePage(IotDevicePageReqVO pageReqVO) {
        // 1. 查询设备列表
        PageResult<IotDeviceDO> pageResult = deviceMapper.selectPage(pageReqVO);
        
        // 2. 批量查询设备在线状态（调用网关）
        List<Long> deviceIds = pageResult.getList().stream()
                .map(IotDeviceDO::getId)
                .collect(Collectors.toList());
        
        String url = GATEWAY_URL + "/gateway/device/status/batch";
        Map<Long, DeviceStatusVO> statusMap = restTemplate.postForObject(
                url,
                deviceIds,
                new ParameterizedTypeReference<Map<Long, DeviceStatusVO>>() {}
        );
        
        // 3. 组装返回VO
        List<IotDeviceRespVO> respList = pageResult.getList().stream()
                .map(device -> {
                    IotDeviceRespVO respVO = new IotDeviceRespVO();
                    respVO.setId(device.getId());
                    respVO.setDeviceName(device.getDeviceName());
                    
                    // 填充在线状态
                    DeviceStatusVO status = statusMap.get(device.getId());
                    if (status != null) {
                        respVO.setOnline(status.getOnline());
                        respVO.setStatus(status.getStatus());
                    }
                    
                    return respVO;
                })
                .collect(Collectors.toList());
        
        return new PageResult<>(respList, pageResult.getTotal());
    }
}
```

---

### 3. 前端：展示设备在线状态

#### 设备列表页面

```vue
<template>
  <el-table :data="deviceList">
    <el-table-column label="设备名称" prop="deviceName" />
    <el-table-column label="在线状态" width="100">
      <template #default="{ row }">
        <el-tag :type="row.online ? 'success' : 'danger'">
          {{ row.online ? '在线' : '离线' }}
        </el-tag>
      </template>
    </el-table-column>
    <el-table-column label="最后变更时间" prop="lastChangeTime" />
  </el-table>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { getDevicePage } from '@/api/iot/device'

const deviceList = ref([])

const loadDeviceList = async () => {
  const { data } = await getDevicePage({ pageNo: 1, pageSize: 10 })
  deviceList.value = data.list
}

onMounted(() => {
  loadDeviceList()
  
  // 可选：定时刷新（30秒）
  setInterval(loadDeviceList, 30000)
})
</script>
```

#### 实时状态推送（WebSocket/SSE）

**未来扩展**：网关可以提供 WebSocket/SSE 接口，推送设备状态变更事件，前端订阅后实时更新UI。

```javascript
// 示例：WebSocket 订阅设备状态变更
const ws = new WebSocket('ws://localhost:48082/gateway/device/status/subscribe')

ws.onmessage = (event) => {
  const statusChange = JSON.parse(event.data)
  // { deviceId: 123, online: false, reasonCode: 'CONNECTION_LOST' }
  
  // 更新设备列表中的状态
  updateDeviceStatus(statusChange.deviceId, statusChange.online)
}
```

---

## 网关接口清单

| 接口 | 方法 | 路径 | 说明 |
|------|------|------|------|
| 查询单个设备状态 | GET | `/gateway/device/status/get?deviceId={id}` | 返回设备在线状态 |
| 批量查询设备状态 | POST | `/gateway/device/status/batch` | 请求体：`[deviceId1, deviceId2, ...]` |
| 获取所有在线设备 | GET | `/gateway/device/status/online-devices` | 返回在线设备ID列表 |
| 注册ONVIF设备 | POST | `/gateway/device/status/onvif/register` | 注册摄像头设备信息 |
| 注销ONVIF设备 | DELETE | `/gateway/device/status/onvif/unregister?deviceId={id}` | 注销摄像头设备信息 |

---

## 响应格式

### DeviceStatusVO

```json
{
  "deviceId": 123,
  "online": true,
  "status": 1,
  "lastChangeTime": "2025-11-21T18:30:00",
  "reasonCode": "CONNECTION_PRESENT",
  "source": "ConnectionPresence"
}
```

**字段说明**：
- `deviceId`：设备ID
- `online`：是否在线（true/false）
- `status`：状态码（1=在线, 2=离线, 3=降级, 0=未知）
- `lastChangeTime`：最后状态变更时间
- `reasonCode`：原因码（CONNECTION_PRESENT、ONVIF_PROBE_SUCCESS等）
- `source`：数据来源（哪个Provider提供的）

---

## 常见问题

### Q1：摄像头状态查询延迟较高？

**A**：ONVIF探测有30秒缓存，首次查询会触发实际探测（800ms超时）。建议：
- 前端使用"加载中"状态
- 批量查询时使用并发优化
- 考虑使用WebSocket推送替代轮询

### Q2：如何判断设备是否支持ONVIF？

**A**：在设备发现或激活时，通过ONVIF扫描器检测。如果设备支持ONVIF，在创建时注册到 `OnvifPresenceProvider`。

### Q3：设备删除后如何清理？

**A**：设备删除时，调用网关的注销接口：
```java
onvifPresenceProvider.unregisterDevice(deviceId);
```

### Q4：如何扩展其他设备类型的状态判断？

**A**：实现新的 `DeviceStatusProvider`，例如：
- `HeartbeatPresenceProvider`：基于心跳超时
- `VendorSdkPresenceProvider`：基于厂商SDK
- `HttpProbeProvider`：基于HTTP健康检查

---

## 总结

1. **网关侧**：已实现统一的设备状态查询架构，支持多Provider聚合
2. **业务侧**：通过HTTP接口调用网关查询设备状态，注册摄像头设备信息
3. **前端侧**：展示设备在线状态，可选实时推送
4. **扩展性**：可轻松接入新的设备类型和状态判断方式

**下一步**：
- 实现WebSocket/SSE推送（实时状态变更通知）
- 接入厂商SDK Provider（海康、大华等）
- 完善设备产品配置（指定设备类型使用哪些Provider）
