# IoT NewGateway 二次开发指南

## 目录

1. [项目架构概述](#1-项目架构概述)
2. [启动流程分析](#2-启动流程分析)
3. [核心框架详解](#3-核心框架详解)
4. [插件系统详解](#4-插件系统详解)
5. [消息队列使用](#5-消息队列使用)
6. [设备状态管理](#6-设备状态管理)
7. [数据模型详解](#7-数据模型详解)
8. [添加新插件指南](#8-添加新插件指南)
9. [性能与并发考虑](#9-性能与并发考虑)
10. [测试策略](#10-测试策略)
11. [故障排查](#11-故障排查)

---

## 1. 项目架构概述

### 1.1 架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         IoT NewGateway Server                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        Consumer Layer (消费者层)                     │    │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────────┐    │    │
│  │  │DeviceCommand    │  │DeviceConnect    │  │ ... 其他消费者   │    │    │
│  │  │Consumer         │  │Consumer         │  │                  │    │    │
│  │  └────────┬────────┘  └────────┬────────┘  └────────┬─────────┘    │    │
│  └───────────┼────────────────────┼────────────────────┼──────────────┘    │
│              │                    │                    │                    │
│              ▼                    ▼                    ▼                    │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        Core Framework (核心框架)                     │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌────────────┐  │    │
│  │  │ Plugin      │  │ Device      │  │ Message     │  │ Command    │  │    │
│  │  │ Registry    │  │ Lifecycle   │  │ Publisher   │  │ Router     │  │    │
│  │  │             │  │ Manager     │  │             │  │            │  │    │
│  │  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └─────┬──────┘  │    │
│  │         │                │                │               │          │    │
│  │         └────────────────┼────────────────┼───────────────┘          │    │
│  └──────────────────────────┼────────────────┼──────────────────────────┘    │
│                             │                │                               │
│                             ▼                ▼                               │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                        Plugin Layer (插件层)                         │    │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────────────┐ │    │
│  │  │  Alarm    │  │ Changhui  │  │    NVR    │  │   Access Gen1/2   │ │    │
│  │  │  Plugin   │  │  Plugin   │  │  Plugin   │  │     Plugin        │ │    │
│  │  │ (Passive) │  │ (Passive) │  │ (Active)  │  │    (Active)       │ │    │
│  │  └───────────┘  └───────────┘  └───────────┘  └───────────────────┘ │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      │ RocketMQ
                                      ▼
                    ┌─────────────────────────────────┐
                    │         IoT Biz Server          │
                    │   (业务服务 - 数据库操作)        │
                    └─────────────────────────────────┘
```

### 1.2 核心设计原则

| 原则 | 说明 |
|-----|------|
| **插件化架构** | 每个设备类型作为独立插件，完全隔离 |
| **核心框架与插件分离** | 核心框架提供通用能力，插件专注设备特定逻辑 |
| **配置化启用/禁用** | 通过配置控制插件的启用状态 |
| **消息总线解耦** | 网关与业务层通过 RocketMQ 消息总线解耦 |
| **生命周期管理** | 统一的设备状态管理和状态转换 |

### 1.3 目录结构

```
src/main/java/cn/iocoder/yudao/module/iot/newgateway/
├── IotNewGatewayServerApplication.java    # 启动类
├── consumer/                               # 消息消费者
│   ├── DeviceCommandConsumer.java         # 设备命令消费者
│   ├── DeviceConnectConsumer.java         # 设备连接消费者
│   └── ConsumerConstants.java             # 消费者常量
├── core/                                   # 核心框架
│   ├── annotation/                        # 注解
│   │   └── DevicePlugin.java              # 插件注解
│   ├── config/                            # 配置类
│   │   ├── GatewayCoreConfig.java         # 核心配置
│   │   ├── GatewayPluginProperties.java   # 插件配置
│   │   ├── GatewayStartupProperties.java  # 启动配置
│   │   └── DeviceConfigParser.java        # 设备配置解析
│   ├── connection/                        # 连接管理
│   │   └── ConnectionManager.java         # 连接管理器接口
│   ├── handler/                           # 设备处理器
│   │   ├── DeviceHandler.java             # 基础接口
│   │   ├── ActiveDeviceHandler.java       # 主动连接接口
│   │   └── PassiveDeviceHandler.java      # 被动连接接口
│   ├── lifecycle/                         # 生命周期管理
│   │   ├── DeviceLifecycleManager.java    # 生命周期管理器
│   │   └── DeviceStateChangePublisher.java # 状态变更发布
│   ├── message/                           # 消息发布
│   │   └── GatewayMessagePublisher.java   # 统一消息发布器
│   ├── model/                             # 数据模型
│   │   ├── DeviceCommand.java             # 设备命令
│   │   ├── DeviceConnectionInfo.java      # 连接信息
│   │   ├── DeviceStatus.java              # 设备状态
│   │   ├── CommandResult.java             # 命令结果
│   │   ├── LoginResult.java               # 登录结果
│   │   └── PluginDescriptor.java          # 插件描述符
│   ├── registry/                          # 插件注册
│   │   └── DevicePluginRegistry.java      # 插件注册表
│   ├── router/                            # 命令路由
│   │   └── DeviceCommandRouter.java       # 命令路由器
│   ├── startup/                           # 启动初始化
│   │   ├── GatewayStartupInitializer.java # 启动初始化器
│   │   ├── DeviceInitRetryManager.java    # 重试管理器
│   │   └── InitializationStatistics.java  # 初始化统计
│   ├── health/                            # 健康检查
│   │   ├── GatewayHealthEndpoint.java     # 健康端点
│   │   └── PluginHealthIndicator.java     # 插件健康指示器
│   └── metrics/                           # 指标收集
│       ├── GatewayMetrics.java            # 网关指标
│       └── GatewayMetricsEndpoint.java    # 指标端点
├── plugins/                               # 设备插件
│   ├── PluginConstants.java               # 插件常量
│   ├── alarm/                             # 报警主机插件
│   ├── changhui/                          # 长辉TCP插件
│   ├── nvr/                               # NVR插件
│   ├── accessgen1/                        # 门禁一代插件
│   ├── accessgen2/                        # 门禁二代插件
│   └── template/                          # 模板插件（参考实现）
├── remote/                                # 远程调用
│   └── IotDeviceCommonApiImpl.java        # 设备API实现
└── util/                                  # 工具类
    └── NativeLibraryLoader.java           # 原生库加载
```

---

## 2. 启动流程分析

### 2.1 启动类

```java
@SpringBootApplication(exclude = {
    SecurityAutoConfiguration.class,
    ManagementWebSecurityAutoConfiguration.class
})
@EnableScheduling
public class IotNewGatewayServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(IotNewGatewayServerApplication.class, args);
    }
}
```

**说明：**
- 排除 Spring Security 相关自动配置（网关不需要安全认证）
- 启用定时任务（用于心跳检测、重试等）

### 2.2 启动序列图

```
┌─────────┐ ┌──────────────┐ ┌───────────────┐ ┌──────────────┐ ┌─────────────┐
│ Spring  │ │PluginRegistry│ │StartupInitializer│ │PluginHandler │ │LifecycleManager│
└────┬────┘ └──────┬───────┘ └───────┬───────┘ └──────┬───────┘ └──────┬──────┘
     │             │                 │                │               │
     │ 1. 容器初始化│                 │                │               │
     │─────────────>│                 │                │               │
     │             │                 │                │               │
     │             │ 2. @PostConstruct                │               │
     │             │ 扫描插件        │                │               │
     │             │──────┐         │                │               │
     │             │      │ 扫描 @DevicePlugin 注解 │               │
     │             │<─────┘         │                │               │
     │             │                 │                │               │
     │             │ 3. 注册插件     │                │               │
     │             │──────────────────────────────────>│               │
     │             │                 │                │               │
     │             │                 │ 4. ApplicationReadyEvent       │
     │             │                 │<────────────────               │
     │             │                 │                │               │
     │             │                 │ 5. 延迟初始化  │               │
     │             │                 │ (delaySeconds) │               │
     │             │                 │──────┐        │               │
     │             │                 │      │        │               │
     │             │                 │<─────┘        │               │
     │             │                 │                │               │
     │             │                 │ 6. 获取设备列表 │               │
     │             │                 │ (RPC调用biz)  │               │
     │             │                 │──────┐        │               │
     │             │                 │      │        │               │
     │             │                 │<─────┘        │               │
     │             │                 │                │               │
     │             │                 │ 7. 并行初始化  │               │
     │             │                 │ (ActiveDeviceHandler)          │
     │             │                 │───────────────>│               │
     │             │                 │                │ 8. login()    │
     │             │                 │                │──────┐       │
     │             │                 │                │      │       │
     │             │                 │                │<─────┘       │
     │             │                 │                │               │
     │             │                 │                │ 9. 更新状态   │
     │             │                 │                │──────────────>│
     │             │                 │                │               │ 10. 发布状态
     │             │                 │                │               │ 到消息总线
```

### 2.3 启动初始化配置

```yaml
iot:
  gateway:
    startup:
      enabled: true              # 是否启用启动初始化
      delay-seconds: 10          # 延迟启动时间
      parallelism: 10            # 并行度
      device-timeout-seconds: 60 # 设备超时时间
      batch-size: 50             # 批次大小
      device-interval-ms: 100    # 设备间隔时间
      max-retry-count: 3         # 最大重试次数
      tenant-id: 1               # 租户ID（单租户部署）
      device-type-blacklist:     # 设备类型黑名单
        - ALARM                  # 被动连接设备不需要主动初始化
        - CHANGHUI
```

### 2.4 启动流程详解

1. **Spring 容器初始化**
   - 加载配置
   - 创建 Bean

2. **插件注册 (`DevicePluginRegistry.init()`)**
   - 扫描所有带 `@DevicePlugin` 注解的 Bean
   - 根据配置决定是否启用插件
   - 注册到插件注册表和处理器映射

3. **启动初始化 (`GatewayStartupInitializer.onApplicationReady()`)**
   - 延迟指定时间（确保所有服务就绪）
   - 从 biz 层获取设备列表
   - 过滤设备（根据白名单/黑名单）
   - 并行初始化主动连接设备（调用 `login()`）
   - 被动连接设备只注册元数据，等待设备主动连接

4. **失败重试**
   - 初始化失败的设备加入重试队列
   - 使用指数退避策略重试

---

## 3. 核心框架详解

### 3.1 插件注册表 (`DevicePluginRegistry`)

**职责：**
- 自动扫描和注册插件
- 根据配置启用/禁用插件
- 提供按设备类型查找处理器的能力

**关键方法：**

```java
// 获取设备处理器
DeviceHandler handler = pluginRegistry.getHandler("ALARM");

// 获取所有已启用的插件
Collection<PluginDescriptor> plugins = pluginRegistry.getEnabledPlugins();

// 检查是否支持某设备类型
boolean supported = pluginRegistry.hasHandler("NVR");
```

**插件注解 (`@DevicePlugin`)：**

```java
@DevicePlugin(
    id = "alarm",                          // 插件唯一标识
    name = "报警主机",                      // 显示名称
    deviceType = "ALARM",                  // 设备类型
    vendor = "Generic",                    // 厂商
    description = "报警主机设备",           // 描述
    enabledByDefault = true                // 默认是否启用
)
public class AlarmPlugin implements PassiveDeviceHandler { ... }
```

### 3.2 设备处理器接口

#### 3.2.1 基础接口 (`DeviceHandler`)

```java
public interface DeviceHandler {
    String getDeviceType();                                    // 获取设备类型
    String getVendor();                                        // 获取厂商
    boolean supports(DeviceInfo deviceInfo);                   // 是否支持该设备
    CommandResult executeCommand(Long deviceId, DeviceCommand cmd);  // 执行命令
    DeviceStatus queryStatus(Long deviceId);                   // 查询状态
}
```

#### 3.2.2 被动连接接口 (`PassiveDeviceHandler`)

适用于设备主动连接平台的场景（TCP 心跳）：

```java
public interface PassiveDeviceHandler extends DeviceHandler {
    int getListenPort();                                       // 获取监听端口
    void onConnect(ChannelHandlerContext ctx, String identifier); // 连接事件
    void onHeartbeat(Long deviceId, HeartbeatData data);       // 心跳事件
    void onDisconnect(Long deviceId);                          // 断开事件
    String parseDeviceIdentifier(ByteBuf data);                // 解析设备标识
    
    default long getHeartbeatTimeout() { return 60000L; }      // 心跳超时
    default long getConnectionTimeout() { return 30000L; }     // 连接超时
}
```

#### 3.2.3 主动连接接口 (`ActiveDeviceHandler`)

适用于平台主动连接设备的场景（SDK 登录）：

```java
public interface ActiveDeviceHandler extends DeviceHandler {
    LoginResult login(DeviceConnectionInfo connectionInfo);    // 登录设备
    void logout(Long deviceId);                                // 登出设备
    boolean keepalive(Long deviceId);                          // 保活检测
    
    default long getReconnectInterval() { return 30000L; }     // 重连间隔
    default long getKeepaliveInterval() { return 60000L; }     // 保活间隔
}
```

### 3.3 生命周期管理器 (`DeviceLifecycleManager`)

**状态转换：**

```
┌────────────────────────────────────────────────────────────────┐
│                      设备状态转换图                             │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  主动连接设备 (Active):                                        │
│  INACTIVE ─────login()────→ ONLINE ←────→ OFFLINE              │
│                              │     keepalive失败/登出          │
│                              │                                 │
│  被动连接设备 (Passive):                                       │
│  INACTIVE ─→ ACTIVATED ─→ ONLINE ←────→ OFFLINE                │
│           首次心跳       心跳确认    心跳超时/断开             │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

**关键方法：**

```java
// 原子操作（推荐使用）
boolean success = lifecycleManager.onDeviceConnected(deviceId, connectionInfo);  // 被动设备连接
boolean success = lifecycleManager.onDeviceLogin(deviceId, connectionInfo);      // 主动设备登录
boolean success = lifecycleManager.onDeviceDisconnected(deviceId, reason);       // 设备断开
boolean success = lifecycleManager.onDeviceLogout(deviceId, reason);             // 设备登出

// 状态查询
IotDeviceStateEnum state = lifecycleManager.getState(deviceId);
boolean online = lifecycleManager.isOnline(deviceId);

// 心跳更新
lifecycleManager.updateLastSeen(deviceId);
```

**并发安全：**
- 每个设备有独立的锁对象（`deviceLocks`）
- 原子方法内部使用 `synchronized(getDeviceLock(deviceId))` 保证线程安全
- 使用 `ConcurrentHashMap` 存储状态数据

### 3.4 连接管理器 (`ConnectionManager<T>`)

**泛型参数：**
- 被动连接插件：`Channel`、`NetSocket` 等
- 主动连接插件：`Long`（登录句柄）

**接口定义：**

```java
public interface ConnectionManager<T> {
    void register(Long deviceId, String identifier, T connection);  // 注册连接
    void unregister(Long deviceId);                                 // 注销连接
    T getConnection(Long deviceId);                                 // 获取连接
    Long getDeviceIdByIdentifier(String identifier);                // 根据标识获取ID
    boolean isOnline(Long deviceId);                                // 检查是否在线
    void updateHeartbeat(Long deviceId);                            // 更新心跳
    Long getLastHeartbeatTime(Long deviceId);                       // 获取最后心跳时间
    void closeAll();                                                // 关闭所有连接
}
```

**实现示例：**

```java
@Component
public class AlarmConnectionManager implements ConnectionManager<Channel> {
    private final Map<Long, Channel> deviceConnections = new ConcurrentHashMap<>();
    private final Map<String, Long> identifierDeviceMap = new ConcurrentHashMap<>();
    private final Map<Long, Long> lastHeartbeatMap = new ConcurrentHashMap<>();
    
    @Override
    public void register(Long deviceId, String identifier, Channel connection) {
        // 如果已有连接，先关闭旧连接
        Channel oldChannel = deviceConnections.put(deviceId, connection);
        if (oldChannel != null && oldChannel.isActive()) {
            oldChannel.close();
        }
        identifierDeviceMap.put(identifier, deviceId);
        lastHeartbeatMap.put(deviceId, System.currentTimeMillis());
    }
    // ... 其他方法实现
}
```

### 3.5 命令路由器 (`DeviceCommandRouter`)

**职责：**
- 根据设备类型路由命令到对应插件
- 支持即时登录（设备未连接时自动登录）
- 统一错误处理

```java
CommandResult result = commandRouter.routeAndExecute(
    "NVR",           // 设备类型
    deviceId,        // 设备ID
    command,         // 设备命令
    connectionInfo   // 连接信息（用于即时登录）
);
```

---

## 4. 插件系统详解

### 4.1 插件类型对比

| 类型 | 接口 | 适用场景 | 示例 |
|-----|------|---------|------|
| 被动连接 | `PassiveDeviceHandler` | 设备主动连接平台（TCP 心跳） | 报警主机、长辉 TCP |
| 主动连接 | `ActiveDeviceHandler` | 平台主动连接设备（SDK 登录） | NVR、门禁设备 |

### 4.2 被动连接插件结构

```
plugins/alarm/
├── AlarmPlugin.java              # 插件入口（实现 PassiveDeviceHandler）
├── AlarmConnectionManager.java   # 连接管理器
├── AlarmConfig.java              # 配置类
├── AlarmProtocolCodec.java       # 协议编解码器
├── AlarmTcpServer.java           # TCP 服务器（可选）
├── AlarmMessageType.java         # 消息类型枚举
└── package-info.java
```

### 4.3 主动连接插件结构

```
plugins/nvr/
├── NvrPlugin.java                # 插件入口（实现 ActiveDeviceHandler）
├── NvrConnectionManager.java     # 连接管理器
├── NvrConfig.java                # 配置类
├── NvrSdkWrapper.java            # SDK 封装
├── dto/
│   ├── NvrLoginResult.java       # 登录结果
│   └── NvrOperationResult.java   # 操作结果
└── package-info.java
```

### 4.4 插件生命周期

```
┌─────────────────────────────────────────────────────────────┐
│                    插件生命周期                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 注册阶段 (Spring 容器初始化)                            │
│     ─ @DevicePlugin 注解扫描                               │
│     ─ 根据配置决定启用/禁用                                 │
│     ─ 注册到 DevicePluginRegistry                          │
│                                                             │
│  2. 启动阶段 (ApplicationReadyEvent)                       │
│     ─ TCP 服务器启动（被动连接插件）                        │
│     ─ SDK 初始化（主动连接插件）                            │
│                                                             │
│  3. 运行阶段                                               │
│     ─ 处理设备连接/断开                                     │
│     ─ 执行设备命令                                         │
│     ─ 发布设备事件                                         │
│                                                             │
│  4. 停止阶段 (应用关闭)                                    │
│     ─ 关闭所有设备连接                                      │
│     ─ 释放资源                                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 5. 消息队列使用

### 5.1 消息总线架构

```
┌─────────────────────────────────────────────────────────────────┐
│                     IoT MessageBus (消息总线)                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  NewGateway (发布者)                  Biz (消费者)               │
│  ┌──────────────────┐                ┌──────────────────┐       │
│  │ GatewayMessage   │                │ DeviceState      │       │
│  │ Publisher        │ ──────────────→│ ChangeConsumer   │       │
│  └──────────────────┘                └──────────────────┘       │
│                                                                  │
│  ┌──────────────────┐                ┌──────────────────┐       │
│  │ DeviceState      │                │ DeviceEvent      │       │
│  │ ChangePublisher  │ ──────────────→│ Consumer         │       │
│  └──────────────────┘                └──────────────────┘       │
│                                                                  │
│  Biz (发布者)                        NewGateway (消费者)         │
│  ┌──────────────────┐                ┌──────────────────┐       │
│  │ Device Service   │                │ DeviceCommand    │       │
│  │ Invoke           │ ──────────────→│ Consumer         │       │
│  └──────────────────┘                └──────────────────┘       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 消息主题定义

```java
// iot-core 中的主题常量（IotMessageTopics）
public class IotMessageTopics {
    // 设备状态变更
    public static final String DEVICE_STATE_CHANGED = "iot_device_state_changed";
    
    // 设备事件上报
    public static final String DEVICE_EVENT_REPORTED = "iot_device_event_reported";
    
    // 设备服务调用
    public static final String DEVICE_SERVICE_INVOKE = "iot_device_service_invoke";
    
    // 设备服务结果
    public static final String DEVICE_SERVICE_RESULT = "iot_device_service_result";
    
    // 报警主机相关
    public static final String ALARM_HOST_EVENT = "iot_alarm_host_event";
    public static final String ALARM_HOST_CONTROL_RESPONSE = "iot_alarm_host_control_response";
    
    // NVR 相关
    public static final String NVR_EVENT = "iot_nvr_event";
}
```

### 5.3 消息发布器 (`GatewayMessagePublisher`)

**特性：**
- 统一的消息发布入口
- 强类型约束（禁止使用 Map 类型）
- 自动错误处理（不影响主流程）

```java
// 发布状态变更消息
messagePublisher.publishStateChange(stateChangeMessage);

// 发布设备事件（强类型 DTO）
messagePublisher.publishEvent(IotMessageTopics.DEVICE_EVENT_REPORTED, alarmEvent);

// 发布命令执行结果
messagePublisher.publishCommandResult(IotMessageTopics.DEVICE_SERVICE_RESULT, result);
```

### 5.4 消息消费者

**设备命令消费者 (`DeviceCommandConsumer`)：**

```java
@Component
public class DeviceCommandConsumer implements IotMessageSubscriber<IotDeviceMessage> {
    @Override
    public String getTopic() {
        return IotMessageTopics.DEVICE_SERVICE_INVOKE;
    }
    
    @Override
    public String getGroup() {
        return ConsumerConstants.CONSUMER_GROUP_DEVICE_COMMAND;
    }
    
    @Override
    public void onMessage(IotDeviceMessage message) {
        // 1. 解析消息参数
        // 2. 获取设备处理器
        // 3. 执行命令
        // 4. 发布命令结果
    }
}
```

### 5.5 配置说明

```yaml
# RocketMQ 配置
rocketmq:
  name-server: 192.168.1.126:9876
  producer:
    group: ${spring.application.name}_PRODUCER

# 消息总线类型配置
yudao:
  iot:
    message-bus:
      type: rocketmq  # 必须配置为 rocketmq 才能与 biz 通信
```

---

## 6. 设备状态管理

### 6.1 状态枚举 (`IotDeviceStateEnum`)

```java
public enum IotDeviceStateEnum {
    INACTIVE(0, "未激活"),    // 设备已注册但从未连接
    ONLINE(1, "在线"),        // 设备当前在线
    OFFLINE(2, "离线"),       // 设备连接断开
    ACTIVATED(3, "已激活");   // 被动连接设备首次心跳后的状态
}
```

### 6.2 状态转换规则

**主动连接设备：**
```
INACTIVE → ONLINE → OFFLINE
         login    logout/keepalive失败
           ↑_________|
           重新login
```

**被动连接设备：**
```
INACTIVE → ACTIVATED → ONLINE → OFFLINE
         首次心跳    心跳确认   心跳超时
                      ↑__________|
                      重新心跳
```

### 6.3 状态变更消息

```java
// 状态变更消息结构 (DeviceStateChangeMessage)
{
    "deviceId": 12345,
    "deviceName": "报警主机-001",
    "deviceType": "ALARM",
    "productId": 100,
    "previousState": 1,        // ONLINE
    "newState": 2,             // OFFLINE
    "previousStateName": "在线",
    "newStateName": "离线",
    "tenantId": 1,
    "connectionMode": "PASSIVE",
    "reason": "心跳超时",
    "timestamp": 1704067200000
}
```

### 6.4 最佳实践

1. **使用原子方法**
   ```java
   // 推荐：原子方法自动处理状态转换
   lifecycleManager.onDeviceConnected(deviceId, connectionInfo);
   
   // 不推荐：手动调用多个方法
   lifecycleManager.onDeviceRegistered(deviceId, connectionInfo);
   lifecycleManager.onDeviceActivated(deviceId);
   lifecycleManager.onDeviceOnline(deviceId);
   ```

2. **分离连接管理和状态管理**
   ```java
   // ConnectionManager 只负责连接管理
   connectionManager.register(deviceId, identifier, channel);
   
   // LifecycleManager 负责状态管理
   lifecycleManager.onDeviceConnected(deviceId, connectionInfo);
   ```

---

## 7. 数据模型详解

### 7.1 核心模型

#### DeviceConnectionInfo（设备连接信息）

```java
@Data
@Builder
public class DeviceConnectionInfo {
    private Long deviceId;            // 设备ID
    private String deviceName;        // 设备名称
    private String ipAddress;         // IP地址
    private Integer port;             // 端口
    private String username;          // 用户名
    private String password;          // 密码
    private String deviceType;        // 设备类型
    private String vendor;            // 厂商
    private ConnectionMode connectionMode;  // 连接模式
    private Long productId;           // 产品ID
    private Long tenantId;            // 租户ID
    private Map<String, Object> config;  // 附加配置
}
```

#### DeviceCommand（设备命令）

```java
@Data
@Builder
public class DeviceCommand {
    private String commandType;       // 命令类型
    private Map<String, Object> params; // 命令参数
    
    // 便捷方法
    public <T> T getParam(String key);
    public String getStringParam(String key);
    public Integer getIntParam(String key);
    public Boolean getBooleanParam(String key);
}
```

#### CommandResult（命令结果）

```java
@Data
@Builder
public class CommandResult {
    private boolean success;          // 是否成功
    private String message;           // 消息
    private Object data;              // 返回数据
    
    public static CommandResult success(Object data);
    public static CommandResult failure(String message);
}
```

#### DeviceStatus（设备状态）

```java
@Data
@Builder
public class DeviceStatus {
    private Long deviceId;
    private boolean online;
    private Long lastHeartbeatTime;
    private Long lastActiveTime;
    private Map<String, Object> extInfo;
    
    public static DeviceStatus online(Long deviceId);
    public static DeviceStatus offline(Long deviceId);
}
```

#### PluginDescriptor（插件描述符）

```java
@Data
@Builder
public class PluginDescriptor {
    private String id;                // 插件ID
    private String name;              // 插件名称
    private String deviceType;        // 设备类型
    private String vendor;            // 厂商
    private String description;       // 描述
    private boolean enabled;          // 是否启用
    private Object instance;          // 插件实例
    private PluginStatus status;      // 插件状态
    private Long startTime;           // 启动时间
    
    public enum PluginStatus {
        REGISTERED, STARTING, RUNNING, STOPPED, FAILED
    }
}
```

---

## 8. 添加新插件指南

### 8.1 快速开始

**第一步：复制模板**

```bash
# 复制模板目录
cp -r src/main/java/.../plugins/template src/main/java/.../plugins/mydevice
```

**第二步：重命名文件和类**

| 原文件名 | 新文件名 |
|---------|---------|
| TemplatePlugin.java | MyDevicePlugin.java |
| TemplateConnectionManager.java | MyDeviceConnectionManager.java |
| TemplateConfig.java | MyDeviceConfig.java |

**第三步：修改 @DevicePlugin 注解**

```java
@DevicePlugin(
    id = "mydevice",
    name = "我的设备插件",
    deviceType = "MYDEVICE",
    vendor = "MyVendor",
    description = "我的设备插件描述",
    enabledByDefault = true
)
public class MyDevicePlugin implements PassiveDeviceHandler { ... }
```

**第四步：修改配置前缀**

```java
@ConfigurationProperties(prefix = "iot.newgateway.plugins.mydevice")
public class MyDeviceConfig { ... }
```

**第五步：实现核心方法**

### 8.2 被动连接插件实现

```java
@DevicePlugin(
    id = "mydevice",
    name = "我的设备",
    deviceType = "MYDEVICE",
    vendor = "MyVendor"
)
@RequiredArgsConstructor
public class MyDevicePlugin implements PassiveDeviceHandler {
    
    private final MyDeviceConnectionManager connectionManager;
    private final DeviceLifecycleManager lifecycleManager;
    private final GatewayMessagePublisher messagePublisher;
    private final MyDeviceConfig config;
    
    @Override
    public String getDeviceType() { return "MYDEVICE"; }
    
    @Override
    public String getVendor() { return "MyVendor"; }
    
    @Override
    public int getListenPort() { return config.getPort(); }
    
    @Override
    public String parseDeviceIdentifier(ByteBuf data) {
        // 根据协议解析设备标识符
        // 例如：从数据帧中提取设备账号、序列号等
    }
    
    @Override
    public void onConnect(ChannelHandlerContext ctx, String deviceIdentifier) {
        Long deviceId = lookupDeviceId(deviceIdentifier);
        if (deviceId == null) return;
        
        // 1. 注册连接
        connectionManager.register(deviceId, deviceIdentifier, ctx.channel());
        
        // 2. 构建连接信息
        DeviceConnectionInfo info = buildConnectionInfo(deviceId, deviceIdentifier);
        
        // 3. 原子更新状态
        lifecycleManager.onDeviceConnected(deviceId, info);
    }
    
    @Override
    public void onHeartbeat(Long deviceId, HeartbeatData data) {
        connectionManager.updateHeartbeat(deviceId);
        lifecycleManager.updateLastSeen(deviceId);
    }
    
    @Override
    public void onDisconnect(Long deviceId) {
        lifecycleManager.onDeviceDisconnected(deviceId, "连接断开");
        connectionManager.unregister(deviceId);
    }
    
    @Override
    public CommandResult executeCommand(Long deviceId, DeviceCommand command) {
        switch (command.getCommandType()) {
            case "MY_COMMAND":
                return executeMyCommand(deviceId, command);
            default:
                return CommandResult.failure("不支持的命令类型");
        }
    }
    
    @Override
    public DeviceStatus queryStatus(Long deviceId) {
        return connectionManager.isOnline(deviceId) 
            ? DeviceStatus.online(deviceId) 
            : DeviceStatus.offline(deviceId);
    }
}
```

### 8.3 主动连接插件实现

```java
@DevicePlugin(
    id = "myactivedevice",
    name = "我的主动设备",
    deviceType = "MYACTIVEDEVICE",
    vendor = "MyVendor"
)
@RequiredArgsConstructor
public class MyActiveDevicePlugin implements ActiveDeviceHandler {
    
    private final MyActiveDeviceConnectionManager connectionManager;
    private final DeviceLifecycleManager lifecycleManager;
    private final MyActiveDeviceConfig config;
    private final MySdkWrapper sdkWrapper;
    
    @Override
    public LoginResult login(DeviceConnectionInfo connectionInfo) {
        Long deviceId = connectionInfo.getDeviceId();
        
        // 1. 使用 SDK 登录
        long handle = sdkWrapper.login(
            connectionInfo.getIpAddress(),
            connectionInfo.getPort(),
            connectionInfo.getUsername(),
            connectionInfo.getPassword()
        );
        
        if (handle <= 0) {
            return LoginResult.failure("登录失败: " + sdkWrapper.getLastError());
        }
        
        // 2. 注册连接
        connectionManager.register(deviceId, String.valueOf(handle), handle);
        
        // 3. 原子更新状态
        lifecycleManager.onDeviceLogin(deviceId, connectionInfo);
        
        return LoginResult.success(handle, Map.of("serialNumber", "xxx"));
    }
    
    @Override
    public void logout(Long deviceId) {
        Long handle = connectionManager.getLoginHandle(deviceId);
        if (handle != null) {
            sdkWrapper.logout(handle);
        }
        lifecycleManager.onDeviceLogout(deviceId, "SDK登出");
        connectionManager.unregister(deviceId);
    }
    
    @Override
    public boolean keepalive(Long deviceId) {
        Long handle = connectionManager.getLoginHandle(deviceId);
        if (handle == null) return false;
        
        // 通过查询设备信息验证连接
        boolean valid = sdkWrapper.isConnected(handle);
        if (valid) {
            connectionManager.updateHeartbeat(deviceId);
            lifecycleManager.updateLastSeen(deviceId);
        }
        return valid;
    }
    
    @Override
    public CommandResult executeCommand(Long deviceId, DeviceCommand command) {
        Long handle = connectionManager.getLoginHandle(deviceId);
        if (handle == null) {
            return CommandResult.failure("设备未连接");
        }
        
        // 执行命令
        switch (command.getCommandType()) {
            case "SDK_OPERATION":
                return executeSdkOperation(handle, command);
            default:
                return CommandResult.failure("不支持的命令类型");
        }
    }
}
```

### 8.4 添加插件常量

```java
// PluginConstants.java
public final class PluginConstants {
    // 设备类型
    public static final String DEVICE_TYPE_MYDEVICE = "MYDEVICE";
    
    // 插件ID
    public static final String PLUGIN_ID_MYDEVICE = "mydevice";
}
```

### 8.5 添加配置

```yaml
iot:
  newgateway:
    plugins:
      enabled:
        mydevice: true
      mydevice:
        port: 9900
        heartbeat-timeout: 60000
        connection-timeout: 30000
```

### 8.6 发布设备事件

```java
// 创建强类型事件 DTO
@Data
@Builder
public class MyDeviceEvent implements GatewayEventDTO {
    private Long deviceId;
    private String deviceType;
    private String eventType;
    private Map<String, Object> eventData;
    private long timestamp;
}

// 在插件中发布事件
MyDeviceEvent event = MyDeviceEvent.builder()
    .deviceId(deviceId)
    .deviceType("MYDEVICE")
    .eventType("MY_EVENT")
    .eventData(Map.of("key", "value"))
    .timestamp(System.currentTimeMillis())
    .build();

messagePublisher.publishEvent(IotMessageTopics.DEVICE_EVENT_REPORTED, event);
```

---

## 9. 性能与并发考虑

### 9.1 并发安全设计

| 组件 | 并发策略 |
|-----|---------|
| DeviceLifecycleManager | 设备级别锁（每个设备独立锁） |
| ConnectionManager | ConcurrentHashMap |
| DevicePluginRegistry | ConcurrentHashMap |
| GatewayMessagePublisher | 异步发布，失败不阻塞 |

### 9.2 线程池配置

```yaml
iot:
  gateway:
    startup:
      parallelism: 10           # 启动初始化并行度
    
  newgateway:
    core:
      worker-threads: 4         # 工作线程数
```

### 9.3 性能优化建议

1. **避免全局锁**
   ```java
   // 不推荐：全局锁
   private final Object globalLock = new Object();
   synchronized(globalLock) { ... }
   
   // 推荐：设备级别锁
   private final Map<Long, Object> deviceLocks = new ConcurrentHashMap<>();
   synchronized(getDeviceLock(deviceId)) { ... }
   ```

2. **异步消息发布**
   ```java
   // GatewayMessagePublisher 内部不抛异常，不阻塞主流程
   try {
       messageBus.post(topic, message);
   } catch (Exception e) {
       log.error("发布失败", e);
       // 不抛出异常
   }
   ```

3. **批量初始化**
   ```java
   // 使用线程池并行初始化
   ExecutorService executor = Executors.newFixedThreadPool(parallelism);
   List<Future<InitializationResult>> futures = devices.stream()
       .map(device -> executor.submit(() -> initializeDevice(device)))
       .collect(toList());
   ```

4. **连接风暴防护**
   ```java
   // 设备间隔时间，避免同时连接大量设备
   device-interval-ms: 100
   ```

### 9.4 潜在性能问题

| 问题 | 原因 | 解决方案 |
|-----|------|---------|
| 启动慢 | 大量设备同时初始化 | 增加延迟时间，减少并行度 |
| 内存溢出 | 设备连接数过多 | 限制最大连接数，定期清理 |
| CPU 高 | 心跳检测频繁 | 调整心跳间隔 |
| 消息积压 | RocketMQ 消费慢 | 增加消费者数量 |

---

## 10. 测试策略

### 10.1 单元测试

```java
@Test
void testPluginRegistration() {
    // 准备
    DevicePluginRegistry registry = new DevicePluginRegistry(context, properties);
    
    // 执行
    registry.init();
    
    // 验证
    assertThat(registry.getPluginCount()).isGreaterThan(0);
    assertThat(registry.hasHandler("ALARM")).isTrue();
}

@Test
void testDeviceStateTransition() {
    // 准备
    DeviceLifecycleManager manager = new DeviceLifecycleManager(publisher);
    Long deviceId = 1L;
    
    // 执行
    manager.onDeviceRegistered(deviceId, ConnectionMode.PASSIVE);
    manager.onDeviceActivated(deviceId);
    manager.onDeviceOnline(deviceId);
    
    // 验证
    assertThat(manager.getState(deviceId)).isEqualTo(IotDeviceStateEnum.ONLINE);
}
```

### 10.2 集成测试

```java
@SpringBootTest
class GatewayIntegrationTest {
    
    @Autowired
    private DevicePluginRegistry pluginRegistry;
    
    @Autowired
    private DeviceLifecycleManager lifecycleManager;
    
    @Test
    void testDeviceConnection() {
        // 模拟设备连接
        DeviceHandler handler = pluginRegistry.getHandler("ALARM");
        assertThat(handler).isNotNull();
        
        // 模拟状态变更
        lifecycleManager.onDeviceConnected(1L, connectionInfo);
        assertThat(lifecycleManager.isOnline(1L)).isTrue();
    }
}
```

### 10.3 属性测试（jqwik）

```java
@Property
void commandMappingShouldBeConsistent(@ForAll String commandType) {
    // 验证命令类型映射的正确性
    String mapped = mapCommandType(commandType);
    assertThat(mapped).isNotNull();
}
```

---

## 11. 故障排查

### 11.1 日志配置

```yaml
logging:
  level:
    cn.iocoder.yudao.module.iot.newgateway: INFO
    cn.iocoder.yudao.module.iot.newgateway.core: DEBUG
    cn.iocoder.yudao.module.iot.newgateway.plugins: DEBUG
    cn.iocoder.yudao.module.iot.newgateway.consumer: INFO
```

### 11.2 健康检查端点

```bash
# 健康状态
curl http://localhost:48083/actuator/health

# 网关状态
curl http://localhost:48083/actuator/gateway

# 网关指标
curl http://localhost:48083/actuator/gateway-metrics
```

### 11.3 常见问题排查

| 问题 | 可能原因 | 排查方法 |
|-----|---------|---------|
| 插件未注册 | 注解配置错误 | 检查 @DevicePlugin 注解 |
| 设备连接失败 | 端口被占用 | 检查端口配置 |
| 命令执行失败 | 设备未在线 | 检查设备状态 |
| 消息未发送 | RocketMQ 配置错误 | 检查 message-bus.type 配置 |
| 状态不同步 | 原子操作未使用 | 使用原子方法（onDeviceConnected 等） |

### 11.4 调试技巧

1. **开启 DEBUG 日志**
2. **使用 Actuator 端点监控**
3. **检查 RocketMQ 控制台**
4. **使用断点调试**

---

## 附录

### A. 配置参考

完整配置示例请参考 `src/main/resources/application.yaml`

### B. API 参考

- DeviceHandler 接口
- ConnectionManager 接口
- LifecycleManager 方法

### C. 插件开发检查清单

- [ ] 创建插件目录结构
- [ ] 实现 DeviceHandler 接口
- [ ] 实现 ConnectionManager
- [ ] 添加配置类
- [ ] 在 PluginConstants 添加常量
- [ ] 在 GatewayPluginProperties 添加配置类
- [ ] 在 application.yaml 添加配置
- [ ] 编写单元测试
- [ ] 编写集成测试
- [ ] 更新文档

---

**文档版本：** 1.0  
**最后更新：** 2026-01-07  
**作者：** IoT Gateway Team



